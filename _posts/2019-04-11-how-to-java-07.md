---
layout: post
#标题配置
title: Java学习笔记（7）类和对象
#时间配
date:   2019-04-11 01:17:00 +0800
#大类配置
categories: Java笔记
#小类配置
tag: 笔记
---

* content
{:toc}

---

## 什么是Java中的引用？

引用的概念，如果一个变量的类型是 类类型，而非基本类型，那么该变量又叫做引用。

### 引用和指向

```
new Hero();
```
代表**创建**了一个Hero对象
但是也仅仅是创建了一个对象，没有办法访问它
为了访问这个对象，会使用**引用**来**代表**这个对象
```
Hero h = new Hero();
```
h这个变量是Hero类型，又叫做引用

=的意思指的是h这个引用**代表**右侧创建的对象
“**代表**”在面向对象里，又叫做“**指向**”

![](/styles/images/2019-03-22-how2java/7.1.png)

```java
public class Hero{
	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度
	
	public static void main（String[] args）{
		//创建一个对象
		new Hero();

		//使用一个引用来指向这个对象
		Hero h = new Hero();
	}
}

```

### 多个引用，一个对象

引用有多个，但是对象只有一个。

在这个例子里，所有引用都指向了同一个对象
对象就像“房产”，引用就像“房产证”
房产证的复印件可以有多张，但是真正的“房产”只有这么一处

![](/styles/images/2019-03-22-how2java/7.2.png)

```java
public class Hero{
	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度

	public static void main(String[] args){
		//使用一个引用来指向这个对象
		Hero h1 = new Hero;
		Hero h2 = h1;//h2指向h1所指向的对象
		Hero h3 = h1;
		Hero h4 = h1;
		Hero h5 = h4;

		//h1,h2,h3,h4,h5 五个引用，都指向同一个对象
	}
}
```

### 一个引用，多个对象
第8行，引用garen指向新创建的对象（对象1）
第9行，同一个引用garen指向新创建的对象（对象2）
这个时候，对象1 ，就没有任何引用指向了
换句话说，就没有任何手段控制和访问该对象，那么该对象就变得没有意义。

![](/styles/images/2019-03-22-how2java/7.3.png)

```java
public class Hero{
	public String name;
	protected float hp;

	public static void main(String[] args){
		Hero garen = new Hero();
		garen = new Hero();
	}
}
```

### 练习-引用

如代码，问题
h4所指向的对象和h2所指向的对象，是否是同一个对象？

```java
public class Hero{
	public String name;
	protected float hp;

	public static void main(String[] args){
		Hero h1 = new Hero();
		Hero h2 = new Hero();
		Hero h3;
		Hero h4;
		h3 = h1;
		h4 = h3;
	}
}
```

-----

## 什么是Java中的继承

在LOL游戏中，武器是物品的一种，也是有名称和价格的

所以在设计类的时候，可以让武器继承物品，从而继承物品名称和价格属性

### 物品类 Item

物品类Item，有属性 name, price
```java
public class Item{
	String name;
	int price;
}
```

### 武器类 Weapon （不继承）

武器类：Weapon**不继承Item**的写法

独立设计name和price属性

同时多了一个属性damage攻击力

```java
public class Weapon{
	String name;
	int price;
	int damage;//攻击力
}
```

### 武器类Weapon（继承类Item）

这一次Weapon**继承Item**

虽然自己没有设计name和price ，但是通过继承Item类，也具备了name和price属性

```java
public class Weapon extends Item{
	int damage://攻击力

	public static void main(String[] args){
		Weapon infinityEdge = new Weapon（）；
		infinityEdge.damage = 65;//damage属性在类weapon中新设计的

		infinityEdge.name = "无尽之刃";//name属性，是从Item中继承来的，就不需要重复设计了
		infinityEdge.price = 3600;
	}
}
```

### 练习-护甲

设计一个类Armor护甲
继承Item类，并且额外提供一个属性ac: 护甲等级 int类型

实例化出两件护甲:

|名称| 价格 |护甲等级|
|----|-----|------|
|布甲 | 300 | 15   |
|锁子甲| 500 | 40  |

```java
public class Armor extends Item{
	int ac ;

	public static void main(String[] args){
		Armor clothArmor = new Armor();
		clothArmor.name = "布甲";
		clothArmor.price = 300;
		clothArmor.ac = 15;

		Armor chainmail = new Aromr();
		chainmail.name = "锁子甲";
		chainmail.price = 500;
		chainmail.ac = 40;
	}
}
```

----

## 什么是Java方法重载

方法重载指的是方法名一样，但是参数类型不一样

### attack方法的重载

有一种英雄。叫做物理攻击英雄 ADHero

为ADHero提供三种方法
```java
public void attack()
public void attack(Hero h1)
public void attack(Hero h1,Hero h2)
```

方法名是一样的，但是参数类型不一样
在调用方法attack的时候，会根据传递的参数类型以及数量，自动调用对应的方法

![](/styles/images/2019-03-22-how2java/7.3.png)

```java
public class ADHero extends Hero{
	public void attack(){
		System.out.println(name+"进行了一次攻击，但是不确定打中谁了");
	}

	public void attack(Hero h1){
		System.out.println(name+"对"+h1.name+"进行了一次攻击");
	}

	public void attack(Hero h1,Hero h2){
		System.out.println(name+"对"+h1.name+"和"+h2.name+"进行了攻击");
	}

	public static void main(String[] args){
		ADHero bh = new ADHero();
		bh.name = "赏金猎人";

		Hero h1 = new Hero();
		h1.name = "盖伦";
		Hero h2 = new Hero();
		h2.name = "提莫";

		bh.attack(h1);
		bh.attack(h1,h2);
	}
}
```

### 可变数量的参数

如果要攻击更多的英雄，就需要设计更多的方法，这样类会显得很累赘，像这样：
```
public void attack()
public void attack(h1)
public void attack(h1,h2)
```
这时，可以采用可变数量的参数

**只需要设计一个方法**
`public void attack(Hero... heros)`
即可代表上述所有的方法了
在方法里，使用操作数组的方式处理参数heros即可

```java
public class ADHero extends Hero{
	public void attack(){
		System.out.println(name+"进行了一次攻击，但是不确定打中谁了");
	}
	//可变数量的参数
	public void attack(Hero... heros){
		for(int i = 0;i<heros.length;i++){
			System.out.println(name+"攻击了"+heros[i].name);
		}
	}

	public static void main(String[] args){
		ADHero bh = new ADHero();
		bh.name = "赏金猎人";

		Hero h1 = new Hero();
		h1.name = "盖伦";
		Hero h2 = new Hero();
		h2.name = "提莫";

		bh.attack(h1);
		bh.attack(h1,h2);
	}
}
```

### 练习-治疗

设计一个类Support（辅助英雄）继承Hero，提供一个heal（治疗）方法
对Support的heal方法进行重载
	heal()
	heal(Hero h)//为指定的英雄加血
	heal(Hero h,int hp)//为指定的英雄加了hp 的血

答案：
```java
public class Support extends Hero{
	public void heal(){
		System.out.println(name+"为未指定的英雄加了血");
	}

	public void heal(Hero h){
		System.out.println(name+"为"+h.name+"加了血");
	}
	System void heal(Hero h,int hp){
		System.out.println(name+"为"+h.name+"加了"+hp"血");
	}

	public static void main(String[] args){
		Support soul = new Support();
		soul.name = "魂灵";
		hp = 20;//每次加20血
		Hero h = new Hero();
		h.name = "盖伦";

		soul.heal();
		soul.heal(h);
		soul.heal(h,hp);
	}
}
```

----

## 怎么使用Java构造方法

通过一个类创建一个对象，这个过程叫做**实例化**

实例化是通过调用**构造方法**（又叫做**构造器）实现的

### 什么是构造方法

方法名和类名一样（包括大小写）
**没有返回类型**
实例化一个对象的时候，必然调用构造方法

```java
public class Hero{
	
	String name;

	float hp;

	float armor;

	int moveSpeed;

	//方法名和类名一样（包括大小写）
	//没有返回类型
	public Hero(){
		System.out.println("实例化一个对象的时候，必然调用构造方法");
	}
	public static void main(String[] args){
		//实例化一个对象的时候，必然调用构造方法
		Hero h = new Hero();
	}
}
```

### 隐式的构造方法

Hero类的构造方法是
```
public Hero(){
}
```
这个无参的构造方法，如果不写，就会默认提供一个

```java
public class Hero{
	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度

	//这个无参的构造方法，如果不写，
	//就会默认提供一个无参的构造方法
	// public Hero（）{
	//		System.out.println("调用Hero的构造方法");
	// }

	public static void main(String[] args){
		Hero garen = new Hero();
		garen.name = "盖伦";
		garen.hp = 616.28f;
		garen.armor = 27.536f;
		garen.moveSpeed = 350;

		Hero teemo = new Hero();
		teemo.name = "提莫";
		teemo.hp = 383f;
		teemo.armor = 14f;
		teemo.moveSpeed = 330;
	}
}
```

### 如果提供了一个有参的构造方法

一旦提供了一个有参的构造方法
同时又**没有显式**的提供一个无参的构造方法
那么默认的无参的构造方法，就**没有了**

```java
public class Hero{
	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度

	//有参的构造方法
	//默认的无参的构造方法就失效了
	public Hero(String heroname){
		name = heroname;
	}

	public static void main(String[] args){
		Hero garen = new Hero("盖伦");

		Hero garen = new Hero();//默认的无参构造方法就没有了
	}
}
```

### 构造方法的重载

和普通方法一样，构造方法也可以重载

```java
public class Hero{
	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度

	//带一个参数的构造方法
	public Hero(String heroname){
		name = heroname;
	}

	//带两个参数的构造方法
	public Hero(String name,float herohp){
		name = heroname;
		hp = herohp;
	}

	public static void main(String[] args){
		Hero garen = new Hero("盖伦");
		Hero teemo = new Hero("提莫",383);
	}
}
```

### 练习-构造方法

为Hero设计4参数的构造方法
这四个参数分别是
	String heroName
	float heroHp
	float heroArmor
	int heroMoveSpeed

答案：
```java
public class Hero{
	String name; //姓名
       
    float hp; //血量
       
    float armor; //护甲
       
    int moveSpeed; //移动速度

    //带四个参数的构造方法
    public Hero(String heroName,float heroHp,float heroArmor,int heroMoveSpeed){
		name = heroName;
		hp = heroHp;
		armor = heroArmor;
		moveSpeed = heroMoveSpeed;
    }
}
```

-----

## Java中的this是什么意思？

**this**这个关键字，相当于普通话里的**“我”**

小明说“我吃了”这个时候，“我” 代表小明
小红说“我吃了”这个时候，“我” 代表小红
“**我**”代表当前人物

**this**这个关键字，相当于普通话的“**我**”
**this即代表当前对象**

### this代表当前对象

![this代表当前对象](/styles/images/2019-03-22-how2java/7.5.png)

```java
public class Hero{
	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度

	//打印内存中的虚拟地址
	public void showAddressInMemory(){
		System.out.println("打印this看到的虚拟地址："+this);
	}

	public static void main(String[] args){
		Hero garen = new Hero();
		garen.name = "盖伦";
		//直接打印对象，会显示该对象在内存中的虚拟地址
		//格式：Hero@c17164  c17164即虚拟地址，每次执行，得到的地址不一定一样

		System.out.println("打印对象看到的虚拟地址："+garen);
		//调用showAddressInMemory,打印该对象的this，显示相同的虚拟地址
		garen.showAddressInMemory();

		Hero teemo = new Hero();
		teemo.name = "提莫";
		System.out.println("打印对象看到的虚拟地址："+teemo);
		teemo.showAddressInMemory();
	}
}
```

### 通过this访问属性

通过this关键字访问对象的属性

```java
public class Hero{
	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度

	//参数名和属性名一样
	//在方法体中，只能访问到参数name
	public void setName1(String name){
		name = name;
	}

	//为了避免setName1中的问题，参数名不得不使用其他变量名
	public void setName2(String heroName){
		name = heroName;
	}

	//通过this访问属性
	public void setName3(String name){
		//name 代表的是参数name
		//this.name 代表的是属性name
		this.name = name;
	}

	public static void main(String[] args){
		Hero h = new Hero();

		h.setName1("teemo");
		System.out.println(h.name);

		h.setName2("garen");
		System.out.println(h.name);

		h.setName3("死歌");
		System.out.println(h.name);
	}
}
```

### 通过this调用其他的构造方法

如果要在一个构造方法中，调用另一个构造方法，可以使用 `this()`

```java
public class Hero{
	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度

	//带一个参数的构造方法
	public Hero(String name){
		System.out.println("一个参数的构造方法");
		this.name = name;
	}

	//带两个参数的构造方法
	public Hero(String name,float hp){
		this(name);//等同于this.name = name;
		System.out.println("两个参数的构造方法");
		this.hp = hp;
	}

	public static void main(String[] args){
		Hero teemo = new Hero("提莫",383);

		System.out.println(teemo.name);
	}
}
```

### 练习-构造方法

设计一个构造方法，但是参数名称不太一样，分别是
	String name
	float hp
	float armor
	int moveSpeed
不仅如此，在这个构造方法中，调用这个构造方法
```
public Hero(String name,float hp)
```
答案：
```java
public class Hero{
	String name;

	float hp;

	float armor;

	int moveSpeed;

	//带一个参数的构造方法
	public Hero(String name){
		System.out.println("一个参数的构造方法");
		this.name = name;
	}

	//带两个参数的构造方法
	public Hero(String name,float hp){
		this.name;
		System.out.println("两个参数的构造方法");
		this.hp = hp;
	}

	//带四个参数的构造方法
	public Hero(String name,float hp,float armor,int moveSpeed){
		this(name,hp);
		this.armor = armor;
		this.moveSpeed = moveSpeed;
	}

	public static void main(String[] args){
		Hero teemo = new Hero("提莫",383);
		System.out.println(teemo.name);
		Hero db = new Hero("死歌",400,27,360);
		System.out.println(db.moveSpeed);
	}
}
```

## Java中的传参详解

变量有两种 “基本类型” 和 “类类型”

参数也是变量，所以传参分为：
**基本类型传参**
**类类型传参**

### 基本类型传参

基本类型传参
在方法内，无法修改方法外的基本类型参数

```java
public class Hero{
	String name;//姓名

	float hp; //血量

	float armor;//护甲

	int moveSpeed;//移动速度

	public void huixue(int xp){
		hp = hp + xp;
		//回血完毕后，血瓶 = 0
		xp = 0;
	}

	public Hero(String name,float hp){
		this.name = name;
		this.hp = hp;
	}

	public static void main(String[] args){
		Hero teemo = new Hero("提莫",383);
		//血瓶，其值是100
		int xueping  = 100;

		//提莫通过这个血瓶回血
		teemo.huixue(xueping);

		System.out.println(xueping);
	}
}
```
此时上面的程序输出仍未 100

### 引用 与 =

如果一个变量是基本类型
	比如 int hp = 50
	我们就直接管hp叫变量
	**=表示复制的意思**
如果一个变量是类类型
	比如 Hero h = new Hero();
	我们就管 h 叫做引用。
	**= 不再是赋值的意思**
	**= 表示指向的意思**
比如 Hero h = new Hero();
这句话的意思是
引用 h，指向一个Hero对象

### 类类型传参

**类类型又叫引用**
第24行的引用`teemo`与底17行的`hero`，**是不同的引用**
通过调用`garen.attack(teemo,100);`使得这**两个引用都指向了同一个对象**
所以在第18行`hero.hp = hero.hp - damage;`就使得该对象的hp值，发生了变化
因此第25行，打印该对象的hp值就是变化后的值

![](/styles/images/2019-03-22-how2java/7.6.png)

```java
public class Hero{

	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度

	public Hero(String name,float hp){
		this.name = name;
		this.hp = hp;
	}

	//攻击一个英雄，并让他掉damage点血
	public void attack(Hero hero,int damage){
		hero.hp = hero.hp - damage;
	}

	public static void main(String[] args){
		Hero teemo = new Hero("提莫",383);
		Hero garen = new Hero("盖伦",616);
		garen.attack(teemo,100);
		System.out.println(teemo.hp);
	}
}
```
运行上面的程序，结果输出 ：283（因为383-100）

### 练习-传参

在方法中，使参数引用指向一个新的对象，外面的引用是指向原来的对象？还是新的对象？

```java
public class Hero{

	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度

	public Hero(){

	}

	public Hero(String name,float hp){
		this.name = name;
		this.hp = hp;
	}

	//复活
	public void revive(Hero h){
		h = new Hero("提莫",383);
		//只是h的作用域在这里
		System.out.println("复活",h.hp);
	}

	public static void main(String[] args){
		Hero teemo = new Hero("提莫",383);
		System.out.println(teemo.hp);
		//受到400伤害，挂了
		teemo.hp = teemo.hp - 400;
		System.out.println(teemo.hp);
		//只是调用了方法，但是teemo的hp还没有赋值，所以还是原来的-17
		teemo.revive(teemo);
		System.out.println(teemo.hp);
		//问题：System.out.println(teemo.hp);输出多少？怎么理解
	}
}
```
答案：teemo.hp=-17，不变。传递的是对象变量teemo的值，即对象实际存在堆内存中的地址。方法体开始执行前形参h和teemo都是对同一个堆内存空间的对象（main方法中的new Hero("提莫",383)对象）的引用。而在方法体中我们将h改为了对另一个堆内存空间的对象（复活方法中的new Hero("提莫",383)对象）的引用，而teemo对象变量没有任何改动。

----

## Java中的包package

包：**package**

把比较接近的类，规划在同一个包下

### 把比较相近的类，规划在同一个包下

Hero，ADHero规划在一个包，叫做character（角色）

Item，Weapon规划在另一个包下，叫做property

在最开始的地方声明该类所处于的包名

![](/styles/images/2019-03-22-how2java/7.7.png)

```java
package character;
public class Hero{
	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度
}
```

### 使用其他包下的类，必须import

使用同一个包下的其他类，直接使用即可
但是要使用其他包下的类，必须import

```java
package character;

//Weapon类在其他包里，使用必须进行import
import property.Weapon;

public class Hero{

	String name;//姓名

	float hp;//血量

	float armor;//护甲

	int moveSpeed;//移动速度

	//装备一把武器
	public void equip(Weapon w){
	}
}
```

### 练习-包

创建一个新的包character1，并且让治疗类Support 声明在这个包下

答案：
```java
package character1;
import character.Hero;//必须导入character包下的Hero类

public class Support extends Hero{
	public void heal(){
		System.out.println("对未指定的英雄进行了治疗");
	}

	public void heal(Hero hero){
		System.out.println("对"+hero+"加血");
	}

	public void heal(Hero hero,int hp){
		System.out.println("对"+hero+"加了"+hp+"血");
	}
}
```

----

## Java的四种访问修饰符

成员变量有四种修饰符
	**private**私有的
	**package**/friendly/default不写
	**protected**受保护的
	**public**公共的

比如public表示公共的
```
public String name;
```
而maxHP没有修饰符 即代表 package/friendly/default
```
float maxHP;
```

### 类之间的关系

类和类之间的关系有如下几种：
以Hero为例
**自身**：指的是Hero自己
**同包子类**：ADHero这个类是Hero的子类，并且和Hero处于**同一个包下**
**不同包子类**：Support这个类是Hero的子类，但是在**另一个包下**
**同包类**： GiantDargon这个类和Hero是**同一个包**，但是彼此**没有继承关系**
**其他类**：Item这个类，**在不同包**，也没有继承关系的类

![](/styles/images/2019-03-22-how2java/7.8.png)

### private私有的

使用private修饰属性
	自身：是可以访问的
	同包子类：不能继承
	不同包子类：不能继承
	同包类：不能访问
	其他包类：不能访问
	