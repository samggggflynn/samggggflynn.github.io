---
layout: post
#标题配置
title: 剑指offer（python）
date:   2019-07-24 015:31:00 +0800
#大类配置
categories: 数据结构
#小类配置
tag: 刷题
---

* content
{:toc}
---

# python 剑指offer

python数据结构与算法 讲解牛客网剑指offer66题 

## 斐波那契数列

**题目描述**
大家都知道[斐波那契数列]([https://baike.baidu.com/item/%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97](https://baike.baidu.com/item/斐波那契数列))，现在要求输入一个整数n，请你输出斐波那契数列的第n项（从0开始，第0项为0）。
n<=39

分析：斐波那契数列，形如：1、1、2、3、5、8、13…后一个数为前两位的和；

| n | num |
|---|---|
|n = 0| num = 0|
|n = 1| num = 1|
|n = 2| num = 1|
|n = 3| num = 2|
|……| …… |
|n = k| f(k) = f(k-1)+f(k-2) |

```python
# -*- coding:utf-8 -*-
class Solution:
    def Fibonacci(self, n):
        # write code here
        ''' 递归做法,复杂度太大，2^n，算法复杂度过大不饿能通过测试
        # 但是逻辑实现上是没有问题的，也就是说用递归思路可以解决
        if n == 0:
            return 0
        if n == 1:
            return 1
        if n>1:
        	# f(n)=f(n-1)+f(n-2)
            num = self.Fibonacci(n-1)+self.Fibonacci(n-2)
            return num
        return None
        '''
        
        # 循环方式,时间复杂度n
        if n == 0:
            return 0
        if n == 1:
            return 1
        if n>1:
            a = 1
            b = 0
            ret = 0
            # 总结斐波那契数列的规律为，两个数a、b的和ret
            # 此时ret为这几个数中较大的数，然后令原来两个数中较大的a为b，然后，继续进行相加。依次类推。
            for i in range(0, n-1):
                ret = a + b
                # 将和作为较大数，另原来的较大数为较小数，再进行加和
                b = a
                a = ret
            return ret
        return None
```

**解析：**
斐波那契的递推公式：`F[n]=F[n-1]+F[n-2](n>=3,F[1]=1,F[2]=1)`
![image-20200323151817892](C:\Users\40101\AppData\Roaming\Typora\typora-user-images\image-20200323151817892.png)

如果按照递归来写，时间复杂度随着n的变化：1，2，4，8，…2的n次方，这也就意味着当n较大的时候运算量很大，可能会出现运算超时、内存超出的现象。

循环的方式思路：求a、b的和，将a、b和作为新的较大数，另原来的较大数为新的较小数，再进行加和，依次类推。

## 跳台阶

**题目描述**
一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。

分析：很容易想到递归方式，第一次跳1个台阶，则剩下的跳法f(n-1)；第一次跳2个台阶，则剩下的跳法f(n-2)；所以总的跳法有f(n)=f(n-1)+f(n-2)。(n>=3)

另外，可以通过观察发现，跳台阶的过程就是斐波那契数列，

| num台阶数 | 跳法总类 | 方式 |
|---|---|---|
|num = 0|  0| none|
|num = 1|  1|1|
|num = 2|  2|11、2|
|num = 3|  3|111、12、21|
|num = 4|  5|1111、112、121、211、22|
|……| …… |……|

通过找规律发现，num = n时， f(n) = f(n-1)+f(n-2)  （n>=3）

```python
# -*- coding:utf-8 -*-
class Solution:
    def jumpFloor(self, number):
        # write code here
        # n = 0 没有
        # n = 1 一种
        # n = 2 两种
        # n = 3 3种
        # n = 4 5种
        # 通过找规律发现f(n) = f(n-1)+f(n-2)，当n>2的时候。满足Fabonacci，
        # n = 2, f(2) = 2
        # n = 1, f(1) = 1
        # 或者倒推：设一共有f(n)种跳法，
        # 从后往前，第一步跳1级台阶，剩下有f(n-1)种跳法；
        # 第一步跳2级台阶，剩下有f(n-2)种跳法；但是n必须大于等于3（即f(n-1)和f(n-2)存在
        if number < 1:
            return 0
        if number == 1:
            return 1
        if number == 2:
            return 2
        ret = 0
        a = 1
        b = 2
        for i in range(3, number+1):
            ret = a+b
            a = b
            b = ret
        return ret
```

![image-20200323170355629](C:\Users\40101\AppData\Roaming\Typora\typora-user-images\image-20200323170355629.png)

## 变态跳台阶

**题目描述**
一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。

分析：

| num台阶数 | 跳法总类 | 方式 |
|---|---|---|
|num = 0|  0| none|
|num = 1|  1|1|
|num = 2|  2|11、2|
|num = 3|  4|111、12、21、3|
|num = 4|  8|1111、112、121、211、22、13、31、4|
|……| …… |……|

num=n时，共有2^(n-1)跳法

```python
# -*- coding:utf-8 -*-
class Solution:
    def jumpFloorII(self, number):
        # write code here
        # number = 0,没有
        # number = 1，1
        # number = 2，2
        # number = 3，4
        # number = 4，8种。
        # number = n,2^(n-1)
        # 因为f(n)=f(n-1)+f(n-2)+...+f(2)+f(1),
        # 有f(n-1)=f(n-2)+...+f(2)+f(1)
        # f(n) = 2*f(n-1)
        # ......
        # 其中f(1)=1,f(2)=2
        # 所以f(n)= 2^(n-1)
        if number == 1:
            return 1
        ret = 1
        a = 1
        for i in range(2, number+1):
            ret = 2 * a
            a = ret
        return ret
        # 或者直接一步：
        # return pow(2, number-1)
```

解析：第一次跳1个台阶，剩下f(n-1)跳法；第一次跳2个台阶，剩下f(n-2)跳法；……第一次跳n-2个台阶，剩下f(2)种跳法；第一次跳n-1个台阶，剩下f(1)种跳法。其中f(1)=1,f(2)=2。所以有f(n)=f(n-1)+f(n-2)+...+f(2)+f(1)，有f(n-1)=f(n-2)+...+f(2)+f(1)，所以 f(n) =f(n-1)+f(n-1)= 2 * f(n-1)。所以f(n)=2^(n-1)，其中(n>1),f(1)=1。

## 丑数

**题目描述**
把只包含质因子2、3和5的数称作丑数（Ugly Number）。例如6、8都是丑数，但14不是，因为它包含质因子7。 习惯上我们把1当做是第一个丑数。求按从小到大的顺序的第N个丑数。

分析：考点（数组）。
> 数组的概念，所谓数组，是有序的元素序列 。 若将有限个类型相同的变量的集合命名，那么这个名称为数组名。组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。数组是在程序设计中，为了处理方便， 把具有相同类型的若干元素按无序的形式组织起来的一种形式。 这些无序排列的同类数据元素的集合称为数组。(索引值从0开始)在内存中连续的空间。

**数组是长度固定的，列表是可变长度的，元组也是长度固定的，但是元组的元素值不可变，数组的元素值可变，列表元素值和长度都可以改变。**

栈不同于数组，不可以随意访问，只可以访问栈顶，一次只能取一个。先进后出的结构。在python中也是用列表实现。追加用`append()`（其他语言是push()压入)、获取栈顶用list[-1]、弹出用`pop()`或`delete()`
![image-20200323213916280](C:\Users\40101\AppData\Roaming\Typora\typora-user-images\image-20200323213916280.png)

队列：对于栈只可以从栈顶压入或弹出。对于队列来说，可以从一边添加，另一边取出。先入先出的结构，在python中队列也使用列表实现。添加使用`insert()`或`append()`、取出使用list[-1]、pop()。
![image-20200323214449618](C:\Users\40101\AppData\Roaming\Typora\typora-user-images\image-20200323214449618.png)


## 二维数组中的查找

**题目描述**
在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。


```python
# -*- coding:utf-8 -*-
class Solution:
    # array 二维列表
    def Find(self, target, array):
        # write code here
        '''# 方法一：使用循环遍历查找;
        # 时间复杂度：O(m*n)
        for i in range(len(array)): # len(array)为二维数组行
            for j in range(len(array[0])): # len(array[0])二位数组的列
                if target == array[i][j]:
                    return True
        return False'''
        # 1 2 3 4
        # 3 4 5 6
        # 4 6 8 10
        # 9 11 13 14
        # 第二种：考虑右上角4,构成长方形，比较值的大小
        # 时间复杂度O(m+n)
        # 右上角array[i][j]的值为：value
        row_count = len(array) # 行
        i = 0
        column_count = len(array[0]) # 列
        j = len(array[0])-1
        while i<row_count and j>=0: 
            value = array[i][j] # 依次取每行的最后一个（每行中的最大值）
            if value == target:
                return True
            elif value>target:
                j -= 1 # 如果大了就在同一列减少一点
            else:
                i += 1 # 如果小了就取下一行的最后一位（该行的最大值）
                
        return False
```

解析：查找除了采用常规时间复杂度为`m*n`的遍历方法，还可以根据题目的提示进行灵活取值。

## 替换空格

**题目描述**
请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。

分析：对于python字符串的替换，可以转换成列表list，直接遍历、替换列表元素的方式，使用`.join()`函数可以将列表转换成字符串。

```python
# -*- coding:utf-8 -*-
class Solution:
    # s 源字符串
    def replaceSpace(self, s):
        # write code here
        s = list(s)
        count=len(s)
        for i in range(0,count):
            if s[i]==' ':
                s[i]='%20'
        return ''.join(s) # join()可以使列表转换成字符串
```

## 用两个栈实现队列

**题目描述**
用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。

分析：考虑栈和队列的取数据方式：栈是遵循“先入后出，后入先出”的原则，队列遵循“先入先出”的规则。

![image-20200324092702220](C:\Users\40101\AppData\Roaming\Typora\typora-user-images\image-20200324092702220.png)

```python
# -*- coding:utf-8 -*-
class Solution:
    # 定义两个栈一个用于接收一个用于输出
    def __init__(self):
        # 定义一个栈用于接收
        self.acceptStack=[]
        # 定义一个栈用于输出
        self.outputStack=[]
    def push(self, node):
        # write code here
        # push操作就是在acceptStack上append
        self.acceptStack.append(node)
    def pop(self):
        # return xx
        # 判断是否为空（必须先判断是否为空）
        if self.outputStack == []:
        	# 如果outputStack为空就将从acceptStack中pop出的值添加到outputStack，直到acceptStack为空
            while self.acceptStack != []:
                self.outputStack.append(self.acceptStack.pop())
        
        if self.outputStack != []:
        	# 如果outputStack不为空，那么就可以直接对outputStack做pop操作
            return self.outputStack.pop()
        
        else:
        # 如果outputStack和acceptStack都为空，则返回None
            return None
```

##  旋转数组的最小数字

** 题目描述**
把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。
输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。
例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。
NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。

分析：可以使用遍历，复杂度为O(N);或者考虑二分查找法：

> 二分查找法：二分查找算法（英语：binary search algorithm），也称折半搜索算法（英语：half-interval search algorithm）、对数搜索算法（英语：logarithmic search algorithm），是一种在**`有序`**数组中查找某一特定元素的搜索算法。搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。二分查找算法在情况下的复杂度是对数时间，进行O(log n)次比较操作（n在此处是数组的元素数量，O是大O记号，log 是对数）。二分查找算法使用常数空间，无论对任何大小的输入数据，算法使用的空间都是一样的。除非输入数据数量很少，否则二分查找算法比线性搜索更快，但数组必须事先被排序。

![image-20200326004739840](C:\Users\40101\AppData\Roaming\Typora\typora-user-images\image-20200326004739840.png)
